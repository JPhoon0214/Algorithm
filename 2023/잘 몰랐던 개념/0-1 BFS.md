0-1 BFS
====
<br/>

>### 설명
> 간선의 가중치가 0 또는 1인 특수한 상황에서의 BFS 알고리즘을 부르는 말이다
> 탐색 시작 위치부터 가까운 순서대로 queue에 입력되어 먼저 처리되는 기존 BFS와 마찬가지로 가중치가 0일 경우 기존 cost에 0을 더해 자료구조의 앞에, 가중치가 1일 경우 기존 코스트에 1을 더해 자료구조의 뒤에 저장하는 방식으로 구현된다.
> 다만 후입선출만을 하던 기존 BFS와 달리 가중치에 따라(가중치가 0이면 먼저, 1이면 나중) 나중에 입력된 데이터가 먼저 처리되어야 할 수도 있다. 물론 우선순위큐를 이용해 이를 해결할 수 있지만, 입력이 들어올 때 마다 우선순위 큐를 유지하는 데 logn의 시간이 들게 된다. 이를 위해 자료구조는 큐가 아닌 덱을 사용한다.
>
> 탐색을 위해 덱 안에 있는 위치들을 확인하는 반복문은 최대 정접의 개수인 V번 반복된다. 이때 정정 하나당 방문할 수 있는 최대 간선 수를 SE라고 하면, 이는 V*SE번 시행 될 것이고, 이것은 전체 간선의 개수 E와 같다. 또한 V번 반복되는 반복문 안에서 간선의 탐색 외에 덱에서 원소를 제거하는 등의 상수시간이 걸리는 작업을 하므로, 추가로 V의 시간이 소요된다. 따라서 시간 복잡도는 O(V)와 O(E)중 큰 값, 즉 O(V+E)가 된다.
<br/>

>### 회고
>BFS를 알고 있다면 어느정도 쉽게 코드를 짤 수 있는 알고리즘이었다. 시간 복잡도 분석은...여전히 어렵다...
>다른 사람들의 코드를 찾아보니 내가 짜는 방식과 달리 덱에서 원소를 꺼내 바로 타겟과 확인하는 코드들이 있었다.
>그동안 처음부터 정답값을 찾은 상태일 경우 예외 처리를 해주었는데, 다음번에 이렇게 풀어봐야겠다.